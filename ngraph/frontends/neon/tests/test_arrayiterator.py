# ----------------------------------------------------------------------------
# Copyright 2016 Nervana Systems Inc.
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#      http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# ----------------------------------------------------------------------------
from __future__ import division
import pytest
import numpy as np
from ngraph.frontends.neon import SequentialArrayIterator


@pytest.fixture(scope='module',
                params=[
                    np.arange(10000),
                    np.arange(20000).reshape(10000, 2),
                    np.arange(10001)],
                ids=[
                    'even_seq',
                    'multidim_seq',
                    'odd_seq'])
def input_seq(request):
    return request.param


@pytest.fixture(scope='module',
                params=[8, 32])
def batch_size(request):
    return request.param


@pytest.fixture(scope='module',
                params=[16, 32])
def seq_len(request):
    return request.param


@pytest.mark.parametrize("shuffle", [True, False])
def test_nowindow(input_seq, batch_size, seq_len, shuffle):
    """
    This test checks shuffle and no-shuffle option, with non-overlapping windows
    We check only the first sample in each batch
    """
    # Truncate input sequence such that last section that doesn't fit in a batch
    # is thrown away
    input_seq = input_seq[:seq_len * batch_size * (len(input_seq) // seq_len // batch_size)]
    data_array = {'X': input_seq,
                  'y': np.roll(input_seq, axis=0, shift=-1)}
    time_steps = seq_len
    iterations = None

    if shuffle:
        # Build an array of sequences that should be generated by the iterator
        iterations = 3 * len(input_seq) // batch_size // seq_len
        if len(input_seq.shape) > 1:
            exp_sequences = np.zeros((batch_size * iterations, seq_len, input_seq.shape[1]),
                                     dtype=input_seq.dtype)
        else:
            exp_sequences = np.zeros((batch_size * iterations, seq_len), dtype=input_seq.dtype)

        for i in range(batch_size * iterations):
            idcs = np.arange(i * seq_len, (i + 1) * seq_len) % len(input_seq)
            exp_sequences[i, :] = input_seq[idcs]
        str_list = {}
        sequence_seen = np.zeros((batch_size * iterations,), dtype=bool)

    it_array = SequentialArrayIterator(data_arrays=data_array, time_steps=time_steps,
                                       batch_size=batch_size, tgt_key='y', shuffle=shuffle,
                                       total_iterations=iterations)

    for idx, iter_val in enumerate(it_array):
        # Start of the array needs to be time_steps * idx * batch_size
        start_idx = time_steps * idx * batch_size
        idcs = np.arange(start_idx, start_idx + time_steps * batch_size) % input_seq.shape[0]
        reshape_dims = (batch_size, time_steps)
        if len(input_seq.shape) > 1:
            reshape_dims = (batch_size, time_steps, input_seq.shape[1])
        # expected_x will have contigous non-overlapping samples
        expected_x = data_array['X'][idcs].reshape(reshape_dims)
        expected_y = data_array['y'][idcs].reshape(reshape_dims)

        if shuffle:
            for batch_idx, sample in enumerate(iter_val['X']):
                # Make sure each generated sample is in expected sequences
                # Subtract each sample from exp_sequences, and find absolute difference
                # for each row
                diffs = np.mean(np.abs(exp_sequences - sample),
                                axis=tuple(range(1, len(exp_sequences.shape))))
                assert (np.min(diffs) < 1e-10)

                # Record that this sequence was seen
                sequence_seen[diffs < 1e-10] = True

                # Make sure this sample isn't in its unshuffled position more than twice
                # numpy arrays cannot be members of a set
                # So I convert each sample into a string, and store the string as a key in a dict
                # if the key is seen more than twice, throw out an error
                if np.array_equal(exp_sequences[idx * batch_size + batch_idx], sample):
                    str_array = ''.join(['%1.2f' % i for i in sample.flatten()])
                    if str_array in str_list.keys():
                        str_list[str_array] += 1
                    else:
                        str_list[str_array] = 1
                    assert str_list[str_array] < 3

        else:
            # If we are not shuffling, we need to check consecutive samples are contiguous
            # They will also be non-overlapping
            assert np.array_equal(expected_x, iter_val['X'])
            assert np.array_equal(expected_y, iter_val['y'])

    # Make sure all sequences are seen (in shuffle mode)
    if shuffle:
        assert np.all(sequence_seen)


def test_iterator(input_seq, iterations):
    # create iterator 
    data_array = {'X': input_seq,
                  'y': np.roll(input_seq, axis=0, shift=-1)}
    it_array = SequentialArrayIterator(data_arrays=data_array, time_steps=time_steps,
                                       batch_size=batch_size, tgt_key='y', shuffle=shuffle,
                                       total_iterations=iterations)

    # create expected numpy samples --> set
    input_seq2 = np.copy(input_seq)
    input_seq2 = input_seq2[:seq_len * batch_size * (len(input_seq) // seq_len // batch_size)]

    expected_sequences = set()
    sample2loc = dict()
    
    def samples2charlist():
        # TODO code here

    # for 1 iteration
    for i in range(len(input_seq2)//seq_len):
        idcs = np.arange(i * seq_len, (i + 1) * seq_len) % len(input_seq)
        sample = samples2charlist(input_seq[idcs])
        expected_sequences.add(sample)
        sample2loc[sample] = i

    count = 0
    for idx, iter_val in enumerate(it_array):
        # for every sample in this batch
        minibatch = data_array['X']
        for j, sample in enumerate(minibatch):
            assert sample in expected_sequences  # check sequence is valid
            expected_sequences.pop(sample) 
            if (idx * batch_size + j ) == sample2loc[sample]:
                count += 1
    assert count < some fraction of number of sequences  # check shuffle happened
    assert len(expected_sequnces) == 0      # check every sequence appeared in iterator
            

@pytest.mark.parametrize("strides", [3, 8])
def test_rolling_window(input_seq, batch_size, seq_len, strides):
    # This test checks if the rolling window works
    # We check if the first two samples in each batch are strided by strides

    # Truncate input sequence such that last section that doesn't fit in a batch
    # is thrown away
    input_seq = input_seq[:seq_len * batch_size * (len(input_seq) // seq_len // batch_size)]
    data_array = {'X': input_seq,
                  'y': np.roll(input_seq, axis=0, shift=-1)}
    time_steps = seq_len
    it_array = SequentialArrayIterator(data_arrays=data_array, time_steps=time_steps,
                                       stride=strides, batch_size=batch_size, tgt_key='y',
                                       shuffle=False)
    for idx, iter_val in enumerate(it_array):
        # Start of the array needs to be time_steps * idx
        assert np.array_equal(iter_val['X'][0, strides:time_steps],
                              iter_val['X'][1, :time_steps - strides])
        assert np.array_equal(iter_val['y'][0, strides:time_steps],
                              iter_val['y'][1, :time_steps - strides])
